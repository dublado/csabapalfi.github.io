<!doctype html><html lang="en"><head><meta charset="utf-8"><title>Testing Node.js apps like you mean it</title><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><style>.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#333;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit;font-weight:bolder}.markdown-body h1{font-size:2em;margin:.67em 0}.markdown-body img{border-style:none}.markdown-body code,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body *{box-sizing:border-box}.markdown-body a{color:#4078c0;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body h1,.markdown-body h2{margin-top:0;margin-bottom:0}.markdown-body h1{font-size:32px;font-weight:600}.markdown-body h2{font-size:24px;font-weight:600}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body code{font-family:Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font:12px Consolas,Liberation Mono,Menlo,Courier,monospace}.markdown-body:after,.markdown-body:before{display:table;content:""}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body p,.markdown-body pre{margin-top:0;margin-bottom:16px}.markdown-body h1,.markdown-body h2{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{padding-bottom:.3em;border-bottom:1px solid #eee}.markdown-body h2{font-size:1.5em}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}.markdown-body code:after,.markdown-body code:before{letter-spacing:-.2em;content:"\A0"}.markdown-body pre{word-wrap:normal}.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#4078c0;border:1px solid #4078c0}.hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}.hljs-comment{color:#998;font-style:italic}.hljs-keyword{color:#333;font-weight:700}.hljs-number{color:teal}.hljs-string{color:#d14}.hljs-built_in{color:#0086b3}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}@media screen and (max-width:480px){.markdown-body{padding:15px}}.markdown-body .heading-anchor{color:inherit}</style><article class="markdown-body"><h1>Testing Node.js apps like you mean it</h1><p><a href="https://csabapalfi.github.io">Csaba Palfi</a>, Aug 2014</p><p>I&apos;m now working mostly with Node.js and really happy with the development setup we have. In this post I tried to collect how we do some of our testing.</p><h2><a class="heading-anchor" name="instant-test-feedback" href="#instant-test-feedback">instant test feedback</a></h2><p>... with <code>nodemon</code> and <code>growl</code></p><p>You surely came across <a href="http://nodemon.io/">nodemon</a>. It watches your project files and restarts your server. We also use it to watch and continuously run our tests during development (as a replacement to the not so reliable <code>mocha --watch</code> - <strong>update</strong>: mocha watch is cool these days). You can override the nodemon defaults so that it watches more filetypes. (<code>-e js,json,handlebars</code>)</p><p>Now you have your test running but you have to keep switching to your terminal to see if they pass. Mocha has <a href="https://github.com/visionmedia/node-growl#installation">Growl integration</a> to help with that. (<code>--growl</code>)</p><p>Assuming you have nodemon and mocha+Growl setup and your tests are in the <code>test</code> directory this command keeps running your tests and notifies you if they pass or fail:</p><pre class="hljs">nodemon <span class="hljs-_">-e</span> js,json,handlebars node_modules/mocha/bin/mocha <span class="hljs-built_in">test</span>/ --recursive --growl --reporter spec
</pre><p>You can press save in your editor and expect a Growl notification to tell you the results.</p><h2><a class="heading-anchor" name="keeping-your-tests-clean" href="#keeping-your-tests-clean">keeping your tests clean</a></h2><p>... with <code>unroll</code></p><p>It&apos;s fairly common to run the same tests with different parameters (e.g. you have Scenario Outlines for Cucumber). You can use the brilliant <a href="https://github.com/lawrencec/Unroll">unroll</a> module to achieve similar things with Node test frameworks. Just replace a mocha <code>it()</code> with unroll like below. It&apos;ll produce nicely formatted test description, too.</p><pre class="hljs">  unroll(<span class="hljs-string">&apos;#a plus #b is #c&apos;</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done, testArgs</span>) </span>{
      expect(
        testArgs.a + testArgs.b
      ).to.be.equal(testArgs.c);
      done();
    },
    [
      [<span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;b&apos;</span>, <span class="hljs-string">&apos;c&apos;</span>],
      [ <span class="hljs-number">3</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">8</span> ],
      [ <span class="hljs-number">7</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">7</span> ]
    ]
  );
</pre><h2><a class="heading-anchor" name="easy-acceptance-testing" href="#easy-acceptance-testing">easy acceptance testing</a></h2><p>... with <code>nock</code> and <code>cheerio</code></p><p>Our current stack consists of small Node.js microservices. Most of them just talk to other services via HTTP and either return JSON or render HTML. In our acceptance tests we want to test an entire microservice but mocking their dependencies and asserting on the response they produce.</p><p><a href="https://github.com/pgte/nock">Nock</a> overrides Node&apos;s <code>http.request</code> function and allows you to control what&apos;s going to be the reply to HTTP requests made by your app.</p><p>Let&apos;s see a simple example:</p><pre class="hljs"><span class="hljs-comment">// From now on all requests to example.com/test are mocked</span>
nock(<span class="hljs-string">&apos;http://www.example.com&apos;</span>)
    .get(<span class="hljs-string">&apos;/test&apos;</span>)
    .reply(<span class="hljs-number">200</span>);
</pre><p>It also allows you to control the response body and has a brilliant <a href="https://github.com/pgte/nock#recording">recording</a> feature as well.</p><p>Now that we&apos;re in control of our dependencies we can just run and hit our app with <a href="https://github.com/visionmedia/supertest">supertest</a> and assert on it&apos;s response which is really easy if that&apos;s JSON.</p><p><a href="https://github.com/cheeriojs/cheerio">Cheerio</a> comes handy when we have to assert on an HTML response. Cheerio is a fast implementation of JQuery core for the server.</p><pre class="hljs">$ = cheerio.load(htmlResponse);
expect(
  $(<span class="hljs-string">&apos;h2.title&apos;</span>).text()
).to.be(<span class="hljs-string">&apos;Hi there!&apos;</span>);
</pre><p>And we&apos;re now testing a complete service in isolation from interaction with dependencies to template rendering. Of course this doesn&apos;t replace functional testing with WebDriver but certainly can make functional tests simpler and let them focus on the right things.</p><p><img src="https://ga-beacon.appspot.com/UA-29212656-1/node-testing-tips?pixel" alt=""></p></article></body></html>